"""Convenience classes/functions for Driverless AI Python client."""

import abc
import ast
import collections.abc
import enum
import sys
import time
from typing import Any
from typing import Callable
from typing import Dict
from typing import IO
from typing import List
from typing import Optional
from typing import Sequence
from typing import Union

import tabulate
import toml

from driverlessai import _core


class ClientException(Exception):
    pass


class DatasetExists(ClientException):
    pass


class ExperimentExists(ClientException):
    pass


class InterpretationExists(ClientException):
    pass


class NotSupportedByServer(ClientException):
    pass


class Hyperlink(str):
    """Renders clickable link in notebooks but otherwise behaves the same as ``str``."""

    def _repr_html_(self) -> str:
        link = self.__str__()
        html = (
            "<pre>"
            f"<a href='{link}' rel='noopener noreferrer' target='_blank'>{link}</a>"
            "</pre>"
        )
        return html


class JobStatus(enum.IntEnum):
    SYNCING = -4
    SCHEDULED = -3
    FINISHING = -2
    RUNNING = -1
    COMPLETE = 0
    CANCELLED = 1
    FAILED = 2
    ABORTED_BY_USER = 3
    ABORTED_BY_RESTART = 4
    TIMED_OUT = 5

    def __init__(self, status: int) -> None:
        self.message = {
            -4: "Syncing",
            -3: "Scheduled",
            -2: "Finishing",
            -1: "Running",
            0: "Complete",
            1: "Cancelled",
            2: "Failed",
            3: "Aborted",
            4: "Aborted (by restart)",
            5: "Job timed out",
        }[status]


class ServerObject(abc.ABC):
    """Interact with an entity on the Driverless AI server."""

    def __init__(self, client: "_core.Client", key: Optional[str] = None) -> None:
        self._client = client
        self._key = key
        self._name: Optional[str] = None
        self._raw_info: Any = None

    @property
    def key(self) -> str:
        """Universally unique identifier."""
        if not self._key:
            raise RuntimeError(
                "The Driverless AI server does not provide a universally "
                "unique identifier for this object type."
            )
        return self._key

    @property
    def name(self) -> str:
        """Display name."""
        if not self._name:
            self._update()
        return self._name

    def _get_raw_info(self) -> Any:
        """Returns an undefined object that contains all entity information
        generated by the Driverless AI server. The returned object usually has
        the method ``dump()`` to convert it to a dictionary.
        """
        if not self._raw_info:
            self._update()
        return self._raw_info

    def _set_name(self, name: str) -> None:
        """Use when name is cached before initialization."""
        self._name = name

    def _set_raw_info(self, info: Any) -> None:
        """To be used by ``_update()`` method."""
        self._raw_info = info

    @abc.abstractmethod
    def _update(self) -> None:
        """Updates the object's raw info, name, and properties."""
        raise NotImplementedError


class ServerJob(ServerObject):
    """Monitor a job on the Driverless AI server."""

    def __init__(self, client: "_core.Client", key: str) -> None:
        super().__init__(client=client, key=key)

    def is_complete(self) -> bool:
        """Return ``True`` if job completed successfully."""
        return is_server_job_complete(self._status())

    def is_running(self) -> bool:
        """Return ``True`` if job is scheduled, running, or finishing."""
        return is_server_job_running(self._status())

    def _status(self) -> JobStatus:
        self._update()
        return JobStatus(self._get_raw_info().status)

    def _wait(self, silent: bool = False) -> None:
        status_update = StatusUpdate()
        while self.is_running():
            time.sleep(1)
            if not silent:
                status_update.display(self.status(verbose=2))
        if not silent:
            status_update.display(self.status(verbose=2))
        status_update.end()
        if not self.is_complete():
            raise RuntimeError(
                self._client._backend._format_server_error(self._get_raw_info().error)
            )

    @abc.abstractmethod
    def result(self, silent: bool = False) -> Any:
        """Wait for job to complete.

        Args:
            silent: if True, don't display status updates
        """
        raise NotImplementedError

    def status(self, verbose: int = 0) -> str:
        """Return job status string.

        Args:
            verbose:
                - 0: short description
                - 1: short description with progress percentage
                - 2: detailed description with progress percentage
        """
        status = self._status()
        progress = self._get_raw_info().progress
        # server doesn't always show 100% complete
        if self.is_complete():
            progress = 1
        if verbose == 1:
            return f"{status.message} {progress:.2%}"
        if verbose == 2:
            if status == JobStatus.FAILED:
                message = self._get_raw_info().error
            elif self._get_raw_info().message:
                message = self._get_raw_info().message.split("\n")[0]
            else:
                message = ""
            return f"{status.message} {progress:.2%} - {message}"
        return status.message


class ArtifactExportJob(ServerJob):
    """Monitor export job on the Driverless AI server."""

    def __init__(
        self,
        client: "_core.Client",
        key: str,
        artifact_path: str,
        artifact_file_name: str,
        export_location: str,
    ) -> None:
        # super() calls _update() which relies on artifact_path
        self._artifact_path = artifact_path
        super().__init__(client=client, key=key)
        self._artifact_file_name = artifact_file_name
        self._export_location = export_location

    @property
    def artifact_path(self) -> str:
        """Path to artifact on Driverless AI server."""
        return self._artifact_path

    @property
    def artifact_file_name(self) -> str:
        """Name of artifact file."""
        return self._artifact_file_name

    @property
    def export_location(self) -> str:
        """Location being exported to."""
        return self._export_location

    def _update(self) -> None:
        self._set_raw_info(
            self._client._backend.get_artifact_upload_job(
                key=self.key, artifact_path=self.artifact_path
            )
        )

    def result(self, silent: bool = False) -> None:
        self._wait(silent)

    def status(self, verbose: int = None) -> str:
        status = self._status()
        if status == JobStatus.FAILED:
            message = f" - {self._get_raw_info().error}"
        else:
            message = f" - Export {self.artifact_file_name} to {self.export_location}"
        return f"{status.message}{message}"


class ServerJobs:
    """Monitor multiple jobs on the Driverless AI server."""

    def __init__(self, client: "_core.Client", jobs: Sequence[ServerJob]) -> None:
        self._client = client
        self._jobs = jobs

    @property
    def jobs(self) -> Sequence[ServerJob]:
        """List of ServerJob objects."""
        return self._jobs

    def is_complete(self) -> bool:
        """Return ``True`` if all jobs completed successfully."""
        for job in self.jobs:
            if not job.is_complete():
                return False
        return True

    def is_running(self) -> bool:
        """Return ``True`` if one or more jobs is running or finishing."""
        for job in self.jobs:
            if job.is_running():
                return True
        return False

    def result(self, silent: bool = False) -> Any:
        """Wait for all jobs to complete.

        Args:
            silent: if True, don't display status updates
        """
        return [job.result(silent) for job in self.jobs]

    def status(self, verbose: int = 0) -> List[str]:
        """Returns list of job status strings.

        Args:
            verbose:
                - 0: short description
                - 1: short description with progress percentage
                - 2: detailed description with progress percentage
        """
        return [job.status(verbose) for job in self.jobs]


class ServerObjectList(collections.abc.Sequence):
    """List that lazy loads Driverless AI server objects."""

    def __init__(self, data: Any, get_method: Optional[Callable], item_class_name: str):
        self._data = data
        self._get = get_method
        self._item_class_name = item_class_name

    def __getitem__(self, index: Union[int, slice, tuple]) -> Any:
        if isinstance(index, int):
            if not hasattr(self._data[index], "_client") and self._get is not None:
                item = self._get(self._data[index].key)
                item._set_name(
                    getattr(self._data[index], "name", "")
                    or getattr(self._data[index], "description", "")
                )
                self._data.__setitem__(index, item)
            return self._data[index]
        if isinstance(index, slice):
            return ServerObjectList(self._data[index], self._get, self._item_class_name)
        if isinstance(index, tuple):
            return ServerObjectList(
                [self._data[i] for i in index], self._get, self._item_class_name
            )

    def __len__(self) -> int:
        return len(self._data)

    def __repr__(self) -> str:
        headers = ["", "Type", "Key", "Name"]
        if self._get is None:
            table = [
                [
                    i,
                    self._item_class_name,
                    None,
                    f"{getattr(d, 'name' , '') or getattr(d, 'description' , '')}",
                ]
                for i, d in enumerate(self._data)
            ]
        else:
            table = [
                [
                    i,
                    self._item_class_name,
                    d.key,
                    f"{getattr(d, 'name' , '') or getattr(d, 'description' , '')}",
                ]
                for i, d in enumerate(self._data)
            ]
        return tabulate.tabulate(table, headers=headers, tablefmt="presto")


class StatusUpdate:
    def __init__(self, stdout: IO = sys.stdout) -> None:
        self._needs_end = False
        self._prev_message_len = 0
        self.stdout = stdout

    def _overwrite_line(self, old_line_len: int, new_line: str) -> None:
        """Delete a printed line and write another line in its place.

        Args:
            old_line_len: length of line to be overwritten
            new_line: line to be printed
        """
        self.stdout.write("\r")
        self.stdout.write(" " * old_line_len)
        self.stdout.write("\r")
        self.stdout.write(new_line)
        self.stdout.flush()

    def display(self, message: str) -> None:
        """Display status message on the current line."""
        self._overwrite_line(self._prev_message_len, message)
        self._prev_message_len = len(message)
        self._needs_end = True

    def end(self) -> None:
        """Move to new line."""
        if self._needs_end:
            self.stdout.write("\n")


class Table:
    """Table that pretty prints.

    Args:
        data: two-dimensional list
        headers: column labels
    """

    def __init__(self, data: List[List[Any]], headers: List[str]) -> None:
        self._data = data
        self._headers = headers

    @property
    def data(self) -> List[List[Any]]:
        """Table data."""
        return self._data

    @property
    def headers(self) -> List[str]:
        """Table headers."""
        return self._headers

    def __str__(self) -> str:
        return tabulate.tabulate(self.data, headers=self.headers, tablefmt="presto")

    def _repr_html_(self) -> str:
        return tabulate.tabulate(self.data, headers=self.headers, tablefmt="html")


def check_server_support(
    client: "_core.Client", minimum_server_version: str, parameter: str
) -> None:
    if is_server_version_less_than(client, minimum_server_version):
        raise NotSupportedByServer(
            f"'{parameter}' requires Driverless AI server version "
            f"{minimum_server_version} or higher."
        )


def error_if_dataset_exists(client: "_core.Client", name: str) -> None:
    if name in client._backend.list_datasets_with_similar_name(name):
        raise DatasetExists(
            f"Dataset with name '{name}' already exists on server. "
            "Use `force=True` to create another dataset with same name."
        )


def error_if_experiment_exists(client: "_core.Client", name: str) -> None:
    if name in client._backend.list_models_with_similar_name(name):
        raise ExperimentExists(
            f"Experiment with name '{name}' already exists on server. "
            "Use `force=True` to create another experiment with same name."
        )


def error_if_interpretation_exists(client: "_core.Client", name: str) -> None:
    if name in [i.name for i in client.mli.iid.list()] + [
        i.name for i in client.mli.timeseries.list()
    ]:
        raise InterpretationExists(
            f"Interpretation with name '{name}' already exists on server. "
            "Use `force=True` to create another interpretation with same name."
        )


def is_number(string: Union[bool, float, int, str]) -> bool:
    try:
        float(string)
        return True
    except Exception:  # noqa: B902
        return False


def is_server_job_complete(server_job_status: Union[int, JobStatus]) -> bool:
    return server_job_status == JobStatus.COMPLETE


def is_server_job_running(server_job_status: Union[int, JobStatus]) -> bool:
    return server_job_status in [
        JobStatus.FINISHING,
        JobStatus.RUNNING,
        JobStatus.SCHEDULED,
        JobStatus.SYNCING,
    ]


def is_server_version_less_than(client: "_core.Client", version: str) -> bool:
    server_version_as_list = client.server.version.split(".")
    if len(server_version_as_list) < 4:
        server_version_as_list.append("0")
    server_version_as_tuple = tuple([int(x) for x in server_version_as_list])
    target_version_as_list = version.split(".")
    if len(target_version_as_list) < 4:
        target_version_as_list.append("0")
    target_version_as_tuple = tuple([int(x) for x in target_version_as_list])
    return server_version_as_tuple < target_version_as_tuple


def toml_to_api_settings(
    toml_string: str, default_api_settings: Dict[str, Any], blacklist: List[str]
) -> Dict[str, Any]:
    """Convert toml string to dictionary of API settings.

    If setting not in defaults or is in blacklist, it will be skipped.
    If setting is in defaults but has default value, it will be skipped.
    """
    api_settings = {}
    toml_dict = toml.loads(toml_string)
    for setting, value in toml_dict.items():
        if setting in default_api_settings and setting not in blacklist:
            default_value = default_api_settings[setting]
            if value != default_value:
                api_settings[setting] = value
    return api_settings


def try_eval(value: Any) -> Any:
    try:
        return ast.literal_eval(value)
    except Exception:  # noqa: B902
        return value
